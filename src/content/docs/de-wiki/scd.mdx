---
title: '느린 변경 차원(SCD)'
description: '느린 변경 차원(SCD)의 핵심 개념, 다양한 유형(Type 0, 1, 2, 3, 4, 5, 6, 7), 장단점, 선택 기준, 그리고 실제 활용 사례까지 심층적으로 알아봅니다.'
head:
  - tag: meta
    attrs:
      property: og:image
      content: https://mojito-tech-blog.vercel.app/images/scd.png # 예시 이미지 경로
---
import ComparisonTable from '../../../components/ComparisonTable.astro';
import ReadingTimeInfo from '../../../components/ReadingTimeInfo.astro';
import NormalizationExampleTable from '../../../components/NormalizationExampleTable.astro';
import ChoiceCardGrid from '../../../components/ChoiceCardGrid.astro';

<ReadingTimeInfo minutesRead="10 min read" date="2025-05-24"/>

:::tip[핵심 요약]
**느린 변경 차원(Slowly Changing Dimension, SCD)** 은 데이터 웨어하우스에서 시간의 흐름에 따라 변하는 차원 데이터의 이력을 관리하는 핵심 기법입니다. 

SCD를 통해 과거 특정 시점의 데이터를 정확하게 조회하고 분석할 수 있으며, 데이터의 변경 이력을 어떻게 보존하고 활용할지에 따라 다양한 유형(Type 0~7 등)으로 나뉩니다.

이 글은 각 SCD 유형의 특징과 선택 기준을 상세히 비교하여, 상황에 맞는 최적의 데이터 이력 관리 전략 수립을 돕습니다.
:::

![느린 변경 차원(SCD) 유형 개요](/images/scd.png)

데이터 웨어하우스에서 "시간이 지남에 따라 고객의 주소가 바뀌거나 제품의 카테고리가 변경되면 어떻게 이력을 관리해야 할까요?" 이 질문에 대한 해답이 바로 **느린 변경 차원(SCD)** 입니다. 

차원(Dimension) 테이블은 팩트(Fact) 테이블의 측정값에 컨텍스트를 제공하는 속성(예: 고객명, 제품명, 날짜 등)을 담고 있으며, 이 속성 값들은 영원히 고정되어 있지 않고 때때로 천천히 변합니다.

이 글에서는 주요 SCD 유형들의 핵심 개념과 장단점, 그리고 어떤 상황에서 어떤 유형을 선택해야 하는지에 대한 가이드라인을 제시합니다.

## SCD (Slowly Changing Dimension)란 무엇이며 왜 중요할까요?

SCD는 데이터 웨어하우스에서 **시간에 따라 변하는 차원 속성을 어떻게 다룰 것인가**에 대한 전략입니다. 

예를 들어, 고객의 주소, 결혼 여부, 직업 등은 시간이 지나면서 변경될 수 있는 대표적인 차원 속성입니다. 이러한 변경 사항을 관리하지 않고 단순히 최신 정보로만 업데이트한다면, "작년 이맘때 특정 지역에 거주했던 VIP 고객은 몇 명이었을까?"와 같은 과거 시점 기반의 중요한 분석이 불가능해집니다.

SCD는 다음과 같은 이유로 중요합니다.

*   **정확한 이력 분석**: 과거 특정 시점의 데이터를 정확하게 재현하여 신뢰도 높은 분석을 가능하게 합니다.
*   **의사결정 지원**: 시간에 따른 변화 추이를 파악하여 더 나은 비즈니스 의사결정을 지원합니다.
*   **데이터 무결성 유지**: 차원 데이터 변경에 대한 일관된 규칙을 적용하여 데이터 웨어하우스의 무결성을 높입니다.

SCD 사용 여부를 결정하는 핵심 질문은 **"특정 시점의 과거 사실을 정확히 반영해야 하는가?"** 입니다. 만약 그렇다면, SCD를 통한 이력 관리는 선택이 아닌 필수입니다.

## 주요 SCD 유형 파헤치기

가장 널리 알려진 SCD 유형은 Type 0부터 Type 3까지이며, 이 외에도 여러 변형된 유형들이 존재합니다. 각 유형은 이력 보존 수준, 구현 복잡성, 저장 공간 효율성 등에서 차이를 보입니다.

### SCD Type 0: 변경 없음 (Retain Original)

*   **개념**: 차원 데이터에 어떠한 변경도 허용하지 않거나, 변경이 발생해도 데이터 웨어하우스에는 반영하지 않고 최초 적재된 값을 그대로 유지하는 방식입니다. "Unchanged Dimension"으로도 불립니다.
*   **특징**: 속성 값이 절대 변하지 않는다고 가정하거나, 변경이 비즈니스 분석에 의미가 없을 때 사용합니다.
*   **장점**: 구현이 가장 간단합니다.
*   **단점**: 실제 데이터 변경을 반영하지 못해 현실과 데이터 웨어하우스 간의 불일치가 발생할 수 있습니다.
*   **적용 사례**: 최초 계약일, 생년월일, 날짜 차원의 속성 등 본질적으로 변하지 않는 데이터. 또는 원본 시스템에서만 변경이 관리되고 웨어하우스에서는 초기 스냅샷만 필요한 경우.

### SCD Type 1: 덮어쓰기 (Overwrite)

*   **개념**: 차원 데이터 변경 시, 기존 값을 새로운 값으로 **단순히 덮어씁니다.** 과거 이력은 보존되지 않고 항상 최신 값만 유지됩니다.
*   **특징**: 이전 이력에 대한 정보는 사라집니다.
*   **장점**: 구현이 간단하며, 차원 테이블의 크기가 증가하지 않아 저장 공간 효율적입니다.
*   **단점**: **과거 데이터에 대한 기록을 완전히 잃게 되어** 이력 추적이나 과거 시점 분석이 불가능합니다. 이는 치명적인 단점이 될 수 있습니다.
*   **적용 사례**: 고객 주소 변경 시 과거 주소가 전혀 필요 없는 경우, 오타 수정 등 이력 관리가 중요하지 않은 데이터에 사용됩니다.
*   **ETL 처리**: `MERGE` (또는 `UPSERT`) 구문을 사용하여 대상 테이블에 레코드가 존재하면 업데이트하고, 존재하지 않으면 삽입합니다.

<div class="normalization-example-container">
  <p><strong>SCD Type 1 예시: 고객 주소 변경</strong></p>
  <NormalizationExampleTable
    tableTitle="변경 전 (<code>Customers</code> 테이블)"
    headers={['CustomerID', 'Name', 'Address', 'LastUpdated']}
    rows={[
      ['101', '홍길동', '서울시 강남구', '2023-01-15'],
    ]}
  />
  <p>홍길동 고객의 주소가 '경기도 성남시'로 변경된 경우:</p>
  <NormalizationExampleTable
    tableTitle="변경 후 (<code>Customers</code> 테이블)"
    headers={['CustomerID', 'Name', 'Address', 'LastUpdated']}
    rows={[
      ['101', '홍길동', '경기도 성남시', '2024-05-24'],
    ]}
  />
  <p class="table-note">'서울시 강남구'라는 이전 주소 정보는 사라집니다.</p>
</div>

### SCD Type 2: 새로운 행 추가 (Add New Row)

*   **개념**: 데이터 변경 시 기존 레코드를 덮어쓰거나 수정하는 대신, **변경된 값을 가진 새로운 행을 테이블에 추가**하는 방식입니다.<br/>이전 데이터는 비활성화 표시(예: 유효 종료일 설정)를 통해 보존합니다. **가장 널리 사용되는 방식**으로, 전체 변경 이력을 저장할 수 있습니다.
*   **디자인**: 이력 관리를 위해 다음과 같은 메타데이터 컬럼을 추가합니다.
    *   **대리 키 (Surrogate Key)**: 각 행을 고유하게 식별하는 시스템 생성 키입니다. 원본 시스템의 비즈니스 키(Natural Key)와 별개로 사용됩니다.
    *   **유효 시작일 (Start Date / Effective Date)**: 해당 행의 정보가 유효하기 시작한 날짜/시간.
    *   **유효 종료일 (End Date / Expiration Date)**: 해당 행의 정보가 유효성을 잃은 날짜/시간. 현재 유효한 레코드의 경우 매우 먼 미래 날짜(예: '9999-12-31') 또는 `NULL`로 설정합니다.
    *   **현재 여부 플래그 (Current Flag / IsCurrent)**: 해당 행이 현재 유효한 최신 레코드인지 여부를 나타내는 플래그 (예: 'Y'/'N', TRUE/FALSE, 1/0).
    *   **버전 번호 (Version Number)** (선택 사항): 레코드의 변경 순서를 나타냅니다.
*   **장점**: **모든 과거 정보를 정확하게 보존**하여 시간에 따른 데이터 변화를 상세히 추적하고, 특정 시점의 정확한 분석이 가능합니다.
*   **단점**: 차원 데이터 변경이 잦을 경우 **테이블의 크기가 빠르게 증가**하여 저장 공간을 많이 차지하고, 이는 쿼리 성능 저하로 이어질 수 있습니다. ETL 프로세스 또한 다른 유형에 비해 복잡합니다.
*   **ETL 처리**: 원본 레코드가 대상 테이블에 존재하는지 확인하고, 속성 값 변경 여부를 비교합니다. 변경이 감지되면, 기존 레코드의 `End Date`를 현재 시간 직전으로, `Current Flag`를 'N' 등으로 업데이트하고, 새로운 대리 키와 함께 변경된 데이터를 새 행으로 삽입합니다. 이때 새 행의 `Start Date`는 현재 시간, `End Date`는 미래, `Current Flag`는 'Y' 등으로 설정합니다.
*   **성능 고려사항**: 대규모 데이터셋에서는 Delta Lake의 Z-Order 인덱싱 및 파티셔닝과 같은 최적화 기법을 활용하여 성능 저하를 완화할 수 있습니다.

<div class="normalization-example-container">
  <p><strong>SCD Type 2 예시: 직원 부서 이동</strong></p>
  <NormalizationExampleTable
    tableTitle="변경 전 (<code>Employees</code> 테이블)"
    headers={['EmpKey', 'EmployeeID', 'Name', 'Department', 'StartDate', 'EndDate', 'IsCurrent']}
    rows={[
      ['1', 'E1001', '김철수', '영업팀', '2022-03-01', '9999-12-31', 'Y'],
    ]}
  />
  <p>김철수 직원이 2024-06-01 부로 '마케팅팀'으로 이동한 경우:</p>
  <NormalizationExampleTable
    tableTitle="변경 후 (<code>Employees</code> 테이블)"
    headers={['EmpKey', 'EmployeeID', 'Name', 'Department', 'StartDate', 'EndDate', 'IsCurrent']}
    rows={[
      ['1', 'E1001', '김철수', '영업팀', '2022-03-01', '2024-05-31', 'N'],
      ['2', 'E1001', '김철수', '마케팅팀', '2024-06-01', '9999-12-31', 'Y'],
    ]}
  />
  <p class="table-note">'영업팀' 이력과 '마케팅팀' 이력이 모두 보존됩니다.</p>
</div>

### SCD Type 3: 새로운 컬럼 추가 (Add New Attribute)

*   **개념**: 제한된 변경 이력(주로 **현재 값과 이전 값**)을 저장하기 위해 테이블에 **새로운 컬럼을 추가**하는 방식입니다. 예를 들어, '현재 주소' 컬럼과 '이전 주소' 컬럼을 두는 식입니다.
*   **디자인**: 특정 속성이 변경될 때, 이전 값을 저장할 별도의 컬럼을 추가하여 관리합니다. (예: `Current_State`, `Previous_State`)
*   **장점**: 현재 값과 직전 값을 쉽게 비교 분석할 수 있습니다. Type 2에 비해 구현이 상대적으로 간단하고 저장 공간을 덜 차지합니다. 특정 시나리오(예: 고객 이탈 분석 시 현재 상태와 이전 상태 비교)에 유용합니다.
*   **단점**: **두 번 이상 변경된 이력은 추적할 수 없습니다** (즉, 이전-이전 값은 알 수 없음). 변경 이력을 추적해야 할 속성이 많아지면 테이블이 불필요하게 넓어지고 관리가 복잡해집니다. 이 때문에 "실제로는 드물게 사용된다"고 언급되기도 합니다.
*   **적용 사례**: 고객의 현재 상태와 이전 상태만으로 계산되는 특정 지표(예: 이탈 지표)에 유용합니다.

<div class="normalization-example-container">
  <p><strong>SCD Type 3 예시: 제품 가격 변경 (이전 가격 보존)</strong></p>
  <NormalizationExampleTable
    tableTitle="변경 전 (<code>Products</code> 테이블)"
    headers={['ProductID', 'ProductName', 'CurrentPrice', 'PreviousPrice', 'PriceChangeDate']}
    rows={[
      ['P001', 'A제품', '10000', null, null],
    ]}
  />
  <p>A제품 가격이 2024-05-01 부로 '12000원'으로 변경된 경우:</p>
  <NormalizationExampleTable
    tableTitle="변경 후 (<code>Products</code> 테이블)"
    headers={['ProductID', 'ProductName', 'CurrentPrice', 'PreviousPrice', 'PriceChangeDate']}
    rows={[
      ['P001', 'A제품', '12000', '10000', '2024-05-01'],
    ]}
  />
  <p class="table-note">만약 가격이 한 번 더 변경되면, '10000원'이었던 정보는 사라지고 '12000원'이 <code>PreviousPrice</code>가 됩니다.</p>
</div>

### 기타 SCD 유형 (변형)

기본 유형 외에도 특정 요구사항을 해결하기 위한 여러 변형된 SCD 유형이 존재합니다.

*   **SCD Type 4: 히스토리 테이블 사용 (Dedicated History Table)**
    *   **개념**: 주 차원 테이블은 항상 현재 최신 데이터만 유지하고(Type 1과 유사), 모든 이전 속성 값들은 별도의 히스토리 테이블에 저장하는 방식입니다.
    *   **장점**: 현재 데이터 조회 성능이 빠르며, 이력 테이블을 통해 전체 변경 내역을 추적할 수 있습니다.
    *   **단점**: 이력 조회 시 두 테이블을 조인해야 하므로 쿼리가 복잡해질 수 있습니다.

*   **SCD Type 5: 미니 차원 + Type 1 (Mini-Dimension with Type 1 Outrigger)**
    *   **개념**: 자주 변경되는 속성 그룹을 별도의 '미니 차원'으로 분리하고, 이 미니 차원 키를 팩트 테이블에 저장합니다. 주 차원 테이블의 나머지 속성은 Type 1으로 관리됩니다. 팩트 테이블에는 미니 차원 키와 함께 현재 값을 함께 저장하여 현재 값 조회 성능을 높일 수 있습니다.
    *   **장점**: 대용량 차원 테이블에서 자주 변경되는 일부 속성으로 인한 Type 2의 비대화를 막고, 성능을 개선할 수 있습니다.

*   **SCD Type 6: Type 1 + Type 2 + Type 3 하이브리드 (Combined Approach)**
    *   **개념**: SCD Type 1, Type 2, Type 3의 요소를 조합한 방식입니다.
    *   **디자인**: Type 2처럼 새로운 행을 추가하여 전체 이력을 관리하면서, 현재 값을 가진 행에는 Type 1처럼 특정 속성을 직접 업데이트하고(예: `Current_Address`), 동시에 Type 3처럼 이전 값을 저장하는 컬럼(예: `Previous_Address`)도 가질 수 있습니다. `StartDate`, `EndDate`, `CurrentFlag` 등도 포함됩니다.
    *   **장점**: 하나의 행만 조회해도 현재 값과 직전 값을 비교할 수 있으며, 동시에 모든 이력이 보존되어 유연한 분석이 가능합니다.
    *   **단점**: 테이블 구조가 복잡해지고 데이터 관리가 어려워지며, 데이터 중복이 발생할 수 있습니다.

*   **SCD Type 7: Type 6와 유사 + 현재/과거 테이블 분리 (Dual Type 1 and Type 2)**
    *   **개념**: SCD Type 6와 비슷하지만, 현재 유효한 데이터(대리 키와 비즈니스 키 모두 사용)는 현재 차원 테이블에 Type 1 방식으로 저장하고, 과거 이력은 별도의 테이블에 대리 키를 사용하여 Type 2 방식으로 저장합니다.
    *   **장점**: 현재 데이터 조회 성능이 빠르면서 전체 이력도 보존합니다.
    *   **단점**: 데이터 동기화 및 두 테이블을 함께 조회할 때 로직이 복잡해집니다.

## 📊 주요 SCD 유형 핵심 비교: Type 1, 2, 3

SCD Type 1, Type 2, Type 3은 가장 기본적인 차원 데이터 변경 관리 방식으로, 각각 고유한 특징과 장단점을 가집니다. 다음 표는 세 가지 핵심 유형을 주요 항목별로 비교하여 그 차이점을 명확히 보여줍니다.

<NormalizationExampleTable
  tableTitle="SCD Type 1, 2, 3 핵심 비교"
  headers={['특징', 'SCD Type 1 (덮어쓰기)', 'SCD Type 2 (새로운 행 추가)', 'SCD Type 3 (새로운 컬럼 추가)']}
  rows={[
    ['이력 보존', '보존 안 함 (항상 최신 값만 유지)', '전체 이력 보존', '제한적 이력 보존 (주로 현재 값과 바로 이전 값만)'],
    ['테이블 구조 변경', '없음', '행 수 증가, 메타데이터 컬럼 추가', '이전 값을 저장하기 위한 컬럼 추가'],
    ['구현 복잡성', '낮음', '높음', '중간'],
    ['저장 공간 효율성', '높음', '낮음 (데이터 볼륨 크게 증가 가능성)', '중간'],
    ['과거 시점 분석', '불가능', '가능 (모든 시점의 정확한 분석)', '제한적 (주로 현재 값과 이전 값만 비교 가능)'],
    ['주요 사용 사례', '데이터 오류 수정, 과거 이력이 중요하지 않은 경우', '거의 모든 종류의 이력 관리 요구사항', '현재 값과 이전 값의 빠른 비교가 중요할 때 (예: 이탈 분석)']
  ]}
/>

## 🤔 어떤 SCD 유형을 선택해야 할까요?

최적의 SCD 유형은 하나의 정답이 있는 것이 아니라, **비즈니스 요구사항, 데이터 분석 목적, 데이터 변경 빈도, 저장 용량, 성능 요구사항** 등을 종합적으로 고려하여 결정해야 합니다.

<ChoiceCardGrid>
  <div slot="choiceOne" class="choice-card scd-type1-card">
    <div class="card-header">
      <h3 class="card-title">SCD Type 1 고려 상황</h3>
    </div>
    <ul class="card-content">
      <li>과거 데이터의 이력이 비즈니스적으로 전혀 중요하지 않고, 항상 최신 값만 필요한 경우</li>
      <li>데이터의 사소한 오류를 수정하는 경우</li>
      <li>저장 공간을 최소화하고 구현을 단순하게 유지하고 싶을 때</li>
    </ul>
  </div>
  <div slot="choiceTwo" class="choice-card scd-type2-card">
    <div class="card-header">
      <h3 class="card-title">SCD Type 2 고려 상황</h3>
    </div>
    <ul class="card-content">
      <li>**가장 일반적으로 권장되는 방식**입니다.</li>
      <li>현재 데이터와 과거 데이터 모두 비즈니스에 중요하며, 전체 변경 이력을 추적하고 분석해야 할 때</li>
      <li>특정 시점의 정확한 스냅샷을 재현해야 하는 규제 요건이나 감사 요구가 있을 때</li>
      <li>데이터 볼륨 증가와 그에 따른 성능 영향을 감당할 수 있거나, 최적화할 수 있는 환경일 때</li>
    </ul>
  </div>
  <div slot="choiceThree" class="choice-card scd-type3-card">
    <div class="card-header">
      <h3 class="card-title">SCD Type 3 고려 상황</h3>
    </div>
    <ul class="card-content">
      <li>변경 이력 중 최근 또는 제한된 과거(주로 바로 이전 값)만 필요하고, 전체 이력은 중요하지 않을 때</li>
      <li>현재 값과 이전 값을 빠르게 비교해야 하는 특정 분석(예: 이탈 분석)이 주 목적일 때</li>
      <li>저장 용량 절감 및 처리 속도 향상이 중요하지만, Type 1처럼 이력을 완전히 버릴 수는 없을 때</li>
      <li>단, 속성 변경이 자주 발생하거나 여러 속성의 이력을 추적해야 한다면 부적합합니다.</li>
    </ul>
  </div>
  <div slot="choiceFour" class="choice-card scd-hybrid-card">
    <div class="card-header">
      <h3 class="card-title">기타 유형 (Type 4, 5, 6, 7) 고려 상황</h3>
    </div>
    <ul class="card-content">
      <li>기본 유형(Type 1, 2, 3)의 단점을 보완하거나, 특정 비즈니스 시나리오 및 성능 요구사항을 충족해야 할 때</li>
      <li>예를 들어, 특정 속성만 매우 자주 변경되는 대규모 차원 테이블에는 Type 5 (미니 차원)가 효과적일 수 있습니다.</li>
      <li>매우 복잡한 이력 추적 및 분석 요구사항과 성능 최적화 사이의 균형이 필요할 때 Type 6, 7 등을 고려할 수 있습니다.</li>
    </ul>
  </div>
</ChoiceCardGrid>

SCD 유형 선택은 단순히 기술적인 결정이 아니라, 비즈니스가 데이터를 어떻게 이해하고 활용할 것인지에 대한 장기적인 관점을 반영해야 합니다.

## 🏁 결론

느린 변경 차원(SCD)은 데이터 웨어하우징에서 차원 데이터의 생명주기를 관리하는 핵심적인 기법입니다. 어떤 SCD 전략을 선택하느냐에 따라 데이터 분석의 깊이와 정확성, 그리고 시스템의 효율성이 크게 달라질 수 있습니다.

SCD Type 1, 2, 3은 가장 기본적인 유형이며, 각각의 장단점이 명확합니다. Type 2가 가장 포괄적인 이력 관리를 제공하여 널리 사용되지만, 데이터 증가에 따른 성능 및 비용 문제를 고려해야 합니다. Type 4 이상의 변형된 유형들은 이러한 기본 유형들의 한계를 극복하고 특정 요구사항을 만족시키기 위해 고안되었습니다.

성공적인 데이터 웨어하우스를 구축하고 가치 있는 분석을 수행하기 위해서는 비즈니스 요구사항, 데이터의 특성, 그리고 사용 가능한 기술 스택을 면밀히 검토하여 가장 적절한 SCD 유형을 신중하게 선택하고 구현해야 합니다.
