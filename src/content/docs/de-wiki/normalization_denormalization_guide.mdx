---
title: '데이터 정규화 vs 비정규화'
description: '데이터베이스 설계의 핵심, 정규화와 비정규화를 비교 분석하고 상황에 맞는 최적의 선택을 안내합니다. 주요 개념, 장단점, 사용 사례를 자세히 알아보세요.'
head:
  - tag: meta
    attrs:
      property: og:image
      content: https://mojito-tech-blog.vercel.app/images/normalization-denormalization.png
---
import ComparisonTable from '../../../components/ComparisonTable.astro';
import NormalizationExampleTable from '../../../components/NormalizationExampleTable.astro';
import ReadingTimeInfo from '../../../components/ReadingTimeInfo.astro';

<ReadingTimeInfo minutesRead="6 min read" date="2025-05-16"/>

:::tip[핵심 요약]
**정규화(Normalization)** 는 데이터 중복을 최소화하고 일관성을 확보하는 데이터베이스 구조화 기법인 반면, **비정규화(Denormalization)** 는 읽기 성능을 높이기 위해 의도적으로 데이터 중복을 허용하는 전략입니다. 

이 글은 두 기법의 장단점을 비교하여 상황에 맞는 방식을 찾는 방법에 대해 다루고 있습니다.
:::

![normalization-denormalization](/images/normalization-denormalization.png)

데이터베이스를 설계할 때 `정규화`와 `비정규화`라는 용어를 자주 접하게 됩니다. 

이 두 가지는 방식은 데이터를 구성하고 관리하는 상반된 접근 방식으로, 시스템의 `성능`, `데이터 무결성`, `유지보수 용이성`에 큰 영향을 미칩니다. 

어떤 상황에서 정규화를 선택하고, 언제 비정규화가 더 유리할까요? 지금부터 자세히 살펴보겠습니다.

## Normalization(정규화)이란?

정규화는 데이터 중복을 최소화하고 데이터 일관성과 무결성을 지키기 위해 데이터베이스를 체계적으로 구성하는 과정입니다. 

테이블을 논리적으로 분리하고 관계를 설정하여, 데이터 삽입, 수정, 삭제 시 발생할 수 있는 이상 현상(Anomaly)을 방지하는 과정입니다.

### 정규화의 단계

정규화는 여러 단계의 **정규형(Normal Form)** 으로 나뉘는데, 각각의 단계는 특정 규칙을 적용하여 데이터 중복을 점진적으로 줄여나갑니다.

*   **제1정규형 (1NF)**: 테이블의 모든 컬럼 값이 원자값(더 이상 분해되지 않는 단일 값)을 갖도록 합니다.
    *   **예시**: 고객 테이블의 `전화번호` 컬럼에 여러 값이 한 셀에 있는 경우.

        <div class="normalization-example-container">
          <NormalizationExampleTable
            tableTitle="정규화 전 (<code>고객</code> 테이블)"
            headers={['고객ID', '이름', '전화번호']}
            rows={[
              ['1', '홍길동', "'010-1234-5678, 02-111-2222'"],
              ['2', '김철수', "'010-9876-5432'"],
            ]}
          />
          <p><strong>정규화 후 (<code>고객</code> 테이블과 <code>고객_전화번호</code> 테이블 분리)</strong></p>
          <NormalizationExampleTable
            tableTitle="<code>고객</code> 테이블"
            headers={['고객ID', '이름']}
            rows={[
              ['1', '홍길동'],
              ['2', '김철수'],
            ]}
          />
          <NormalizationExampleTable
            tableTitle="<code>고객_전화번호</code> 테이블"
            headers={['고객ID', '전화번호']}
            rows={[
              ['1', "'010-1234-5678'"],
              ['1', "'02-111-2222'"],
              ['2', "'010-9876-5432'"],
            ]}
          />
        </div>

*   **제2정규형 (2NF)**: 테이블이 **1NF**를 만족하고, 기본 키의 일부에만 종속되는 컬럼(부분 함수 종속)이 없어야 합니다. 복합 기본 키를 사용하는 테이블에서 주로 고려됩니다.
    *   **예시**: `주문_상품` 테이블에서 상품명이 상품번호에만 종속되는 경우 (복합 기본 키: 주문번호, 상품번호).

        <div class="normalization-example-container">
          <NormalizationExampleTable
            tableTitle="정규화 전 (<code>주문_상품</code> 테이블)"
            headers={['주문번호', '상품번호', '상품명', '수량']}
            rows={[
              ['1001', 'P001', '노트북', '1'],
              ['1001', 'P002', '마우스', '1'],
              ['1002', 'P001', '노트북', '2'],
            ]}
          />
          <p><strong>정규화 후 (<code>주문_상품</code> 테이블과 <code>상품</code> 테이블 분리)</strong></p>
          <NormalizationExampleTable
            tableTitle="<code>주문_상품</code> 테이블"
            headers={['주문번호', '상품번호', '수량']}
            rows={[
              ['1001', 'P001', '1'],
              ['1001', 'P002', '1'],
              ['1002', 'P001', '2'],
            ]}
          />
          <NormalizationExampleTable
            tableTitle="<code>상품</code> 테이블"
            headers={['상품번호', '상품명']}
            rows={[
              ['P001', '노트북'],
              ['P002', '마우스'],
            ]}
          />
        </div>

*   **제3정규형 (3NF)**: 테이블이 **2NF**를 만족하고, 기본 키가 아닌 컬럼이 다른 기본 키가 아닌 컬럼에 종속되는 현상(이행적 종속)이 없어야 합니다.
    *   **예시**: `직원` 테이블에서 부서명이 부서코드에 종속되고, 부서위치 또한 부서코드에 종속되는 경우 (기본 키: 직원ID).

        <div class="normalization-example-container">
          <NormalizationExampleTable
            tableTitle="정규화 전 (<code>직원</code> 테이블)"
            headers={['직원ID', '이름', '부서코드', '부서명', '부서위치']}
            rows={[
              ['E01', '홍길동', 'D001', '개발팀', '서울'],
              ['E02', '김철수', 'D002', '기획팀', '판교'],
              ['E03', '이영희', 'D001', '개발팀', '서울'],
            ]}
          />
          <p><strong>정규화 후 (<code>직원</code> 테이블과 <code>부서</code> 테이블 분리)</strong></p>
          <NormalizationExampleTable
            tableTitle="<code>직원</code> 테이블"
            headers={['직원ID', '이름', '부서코드']}
            rows={[
              ['E01', '홍길동', 'D001'],
              ['E02', '김철수', 'D002'],
              ['E03', '이영희', 'D001'],
            ]}
          />
          <NormalizationExampleTable
            tableTitle="<code>부서</code> 테이블"
            headers={['부서코드', '부서명', '부서위치']}
            rows={[
              ['D001', '개발팀', '서울'],
              ['D002', '기획팀', '판교'],
            ]}
          />
        </div>

*   **보이스-코드 정규형 (BCNF)**: **3NF**보다 더 엄격한 정규형입니다. 이 정규형은 모든 결정자가 후보 키여야 합니다.
    *   **예시**: `수강_교수_과목` 테이블에서 (학생ID, 과목명)이 기본 키이고, 교수가 과목에 종속되는 (과목명 → 교수) 경우. 여기서 과목명은 후보 키가 아닙니다.

        <div class="normalization-example-container">
          <NormalizationExampleTable
            tableTitle="정규화 전 (<code>수강_교수_과목</code> 테이블)"
            headers={['학생ID', '과목명', '교수']}
            rows={[
              ['S1001', '데이터베이스', '김교수'],
              ['S1002', '자료구조', '이교수'],
              ['S1001', '자료구조', '이교수'],
            ]}
          />
          <p><strong>정규화 후 (<code>수강_과목</code> 테이블과 <code>과목_교수</code> 테이블 분리)</strong></p>
          <NormalizationExampleTable
            tableTitle="<code>수강_과목</code> 테이블"
            headers={['학생ID', '과목명']}
            rows={[
              ['S1001', '데이터베이스'],
              ['S1002', '자료구조'],
              ['S1001', '자료구조'],
            ]}
          />
          <NormalizationExampleTable
            tableTitle="<code>과목_교수</code> 테이블"
            headers={['과목명', '교수']}
            rows={[
              ['데이터베이스', '김교수'],
              ['자료구조', '이교수'],
            ]}
          />
          <p class="table-note">(주의: 이 예시는 BCNF의 특정 상황을 단순화한 것이며, 실제로는 여러 후보 키와 함수 종속 관계를 더 꼼꼼하게 분석해야 합니다.)</p>
        </div>

*   **제4정규형 (4NF) 이상**: 다치 종속(Multi-valued Dependency) 등 더 복잡한 종속성을 다룹니다.

### 정규화의 장점

위에서 설명한 정규화를 준수할 때는 다음과 같은 장점이 있습니다.

*   **데이터 중복 최소화**: 동일한 정보가 여러 곳에 저장되는 것을 방지하여 저장 공간을 효율적으로 사용합니다.
*   **데이터 무결성 및 일관성 향상**: 데이터가 한 곳에서만 관리되므로 수정 시 불일치 가능성이 줄어듭니다.
*   **유지보수 용이**: 데이터 구조가 명확해지고 변경에 유연하게 대처할 수 있습니다.

### 정규화의 단점

하지만 물리적인 테이블이 늘어나는 만큼 아래와 같은 명확한 단점이 존재합니다.

*   **읽기 성능 저하 가능성**: 데이터가 여러 테이블에 분산되어 있어, 정보 조회 시 여러 테이블을 조인(JOIN)해야 하므로 응답 속도가 느려질 수 있습니다.
*   **쿼리 복잡도 증가**: 원하는 데이터를 얻기 위해 복잡한 쿼리를 작성해야 할 수 있습니다.

## Denormalization(비정규화)이란?

그렇다면 비정규화는 뭘까요?

비정규화는 정규화된 데이터베이스의 읽기 성능을 개선하기 위해 **의도적으로 데이터 중복을 허용**하거나, **테이블을 통합**하는 과정을 말합니다.

*   **예시**: 주문 정보 조회 시 고객 이름과 등급을 함께 보여줘야 하는 경우.

    <div class="normalization-example-container">
      <p><strong>비정규화 전 (정규화된 상태)</strong></p>
      <NormalizationExampleTable
        tableTitle="<code>주문</code> 테이블"
        headers={['주문ID', '고객ID', '주문일자', '총액']}
        rows={[
          ['ORD1001', 'CUST001', '2023-10-26', '150000'],
          ['ORD1002', 'CUST002', '2023-10-26', '85000'],
          ['ORD1003', 'CUST001', '2023-10-27', '220000'],
        ]}
      />
      <NormalizationExampleTable
        tableTitle="<code>고객</code> 테이블"
        headers={['고객ID', '고객명', '고객등급']}
        rows={[
          ['CUST001', '홍길동', 'GOLD'],
          ['CUST002', '김철수', 'SILVER'],
        ]}
      />
      <p>위 상태에서는 주문 목록에 고객명과 등급을 표시하려면 <code>주문</code> 테이블과 <code>고객</code> 테이블을 <code>고객ID</code>로 조인해야 합니다.</p>

      <p><strong>비정규화 후 (<code>주문</code> 테이블에 고객 정보 중복 저장)</strong></p>
      <NormalizationExampleTable
        tableTitle="<code>주문</code> 테이블 (비정규화)"
        headers={['주문ID', '고객ID', '고객명', '고객등급', '주문일자', '총액']}
        rows={[
          ['ORD1001', 'CUST001', '홍길동', 'GOLD', '2023-10-26', '150000'],
          ['ORD1002', 'CUST002', '김철수', 'SILVER', '2023-10-26', '85000'],
          ['ORD1003', 'CUST001', '홍길동', 'GOLD', '2023-10-27', '220000'],
        ]}
      />
      <p>이제 <code>주문</code> 테이블만 조회해도 고객명과 등급을 바로 알 수 있어 읽기 성능이 향상됩니다. <br/>
      하지만 고객 정보 변경 시 <code>고객</code> 테이블과 <code>주문</code> 테이블의 중복된 데이터를 모두 수정해야 하는 부담이 생깁니다.</p>
    </div>

### 비정규화의 장점

이러한 비정규화는 정규화된 테이블에 비해 쿼리 실행 시 조인 횟수가 줄어들어 읽기 성능이 향상되며, 필요한 데이터가 한 테이블에 모여 있어 쿼리 작성이 쉬워집니다.

### 비정규화의 단점

하지만 동일 데이터가 여러 테이블에 존재할 수 있게되어 저장 공간을 효율적으로 사용하기 어려워지며, 중복된 데이터 중 일부만 수정될 경우 데이터 일관성이 깨질 수 있습니다.

따라서 데이터 삽입, 수정, 삭제 시 데이터 일관성을 유지하기 위해 더 복잡한 작업이 필요하며, 성능이 저하될 수 있습니다.

## 정규화 vs 비정규화: 핵심 비교

<ComparisonTable
  title="정규화 vs 비정규화: 핵심 비교"
  firstTitle="정규화"
  secondTitle="비정규화"
  rows={[
    {
      feature: "주요 목표",
      first: "데이터 중복 제거, 데이터 일관성 및 무결성 유지",
      second: "읽기 성능 향상, 쿼리 복잡성 감소"
    },
    {
      feature: "데이터 중복",
      first: "최소화 또는 제거",
      second: "의도적으로 추가"
    },
    {
      feature: "테이블 수",
      first: "증가 가능",
      second: "감소 가능 (테이블 병합)"
    },
    {
      feature: "데이터 무결성",
      first: "높게 유지",
      second: "관리 복잡성 증가, 불일치 위험 존재"
    },
    {
      feature: "읽기 성능",
      first: "조인으로 인해 느릴 수 있음",
      second: "일반적으로 빠름"
    },
    {
      feature: "쓰기 성능",
      first: "일반적으로 빠름",
      second: "중복 데이터 업데이트로 인해 느릴 수 있음"
    },
    {
      feature: "저장 공간",
      first: "효율적",
      second: "비효율적일 수 있음 (중복 데이터)"
    },
    {
      feature: "주요 사용 환경",
      first: "OLTP 시스템, 데이터 변경이 빈번한 애플리케이션",
      second: "OLAP 시스템, 데이터 웨어하우스, BI 리포팅, 읽기 중심 시스템"
    },
    {
      feature: "설계 복잡성",
      first: "초기 설계 및 유지보수가 장기적으로 용이",
      second: "데이터 일관성 관리가 복잡해질 수 있음"
    }
  ]}
/>

## 언제, 어떤 방식을 선택해야 할까요?

어떤 서비스도 정규화와 비정규화 중 한 가지 방법만 고집하여 적용시키지는 않습니다.

항상 시스템의 목적과 특성, 데이터의 활용 방식에 따라 적절한 방식을 섞어서 사용해야 하죠.

### 정규화를 우선 고려하는 경우

*   **데이터 일관성과 정확성이 매우 중요할 때**: 주문 처리 시스템(OLTP)처럼 데이터의 삽입, 수정, 삭제가 빈번하고 데이터 무결성이 최우선인 경우 정규화된 모델이 적합합니다.
*   **데이터 모델이 자주 변경될 가능성이 있을 때**: 정규화는 데이터 구조를 유연하게 만들어 데이터 모델 변경에 더 쉽게 대응할 수 있도록 합니다.
*   **저장 공간을 효율적으로 사용해야 할 때**: 중복을 최소화하여 디스크 공간을 절약할 수 있습니다.

### 비정규화를 고려할 수 있는 경우

*   **읽기 성능이 매우 중요하고, 응답 속도가 빨라야 할 때**: 데이터 웨어하우스, BI(비즈니스 인텔리전스) 리포팅 시스템, 분석 시스템(OLAP)처럼 대량의 데이터를 빠르게 조회하고 분석해야 하는 경우 비정규화가 유리합니다.
*   **데이터 조회가 매우 빈번하게 발생할 때**: 조인 연산을 줄여 시스템 부하를 낮추고 사용자 경험을 개선할 수 있습니다.
*   **데이터 업데이트 빈도가 낮고, 주로 읽기 전용으로 사용될 때**: 데이터 불일치 발생 가능성을 관리하기 용이합니다.

## JSON을 활용한 비정규화

최근에는 관계형 데이터베이스에서도 `JSON` 타입을 지원하면서, 이를 활용한 비정규화 기법도 사용됩니다. 

예를 들어, 주문 테이블에 주문 항목 정보를 `JSON` 배열 형태로 저장하면, 별도의 주문 항목 테이블 없이도 관련된 모든 정보를 한 번에 조회할 수 있어 읽기 성능을 높일 수 있습니다.

하지만 `JSON` 타입으로 저장된 데이터는 수정을 하거나, 복잡한 조건 검색에 대해서는 어려울 수 있으므로, 데이터의 특성과 사용 패턴을 잘 고려해야 합니다.

## 결론

위에서 언급했듯이 대부분의 현대적인 시스템은 정규화와 비정규화의 요소를 모두 활용하는 하이브리드 접근 방식을 주로 사용합니다.

중요한 것은 `시스템 목적`, `데이터 특성`, `성능 요구사항`, `개발 및 유지보수 비용` 등 여러 요소를 종합적으로 고려해 어떤 방식을 사용할지 판단하는 것입니다.

이처럼 정규화와 비정규화의 장단점을 명확히 이해하고 상황에 맞게 잘 적용된 서비스라면 안정적이면서도 효율적인 데이터 관리가 가능할 것입니다.